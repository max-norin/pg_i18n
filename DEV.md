# Заметки

1. `DEFAULT` используется внутри запроса только для полей primary keys - для сохранения вычислений последовательностей.
   В иных случаях использовать `DEFAULT` нет возможности, так как нельзя выяснить внутри триггерной функции или внутри правила
   какая колонка имела значение `DEFAULT` в изначальном запросе.
   Использование `IS DISTINCT FROM` ни к чему не привело.
   Через `GET DIAGNOSTICS stack = PG_CONTEXT;` и переменные `TG_*` нет возможности получить изначальный запрос,
   чтобы так же можно было использовать `DEFAULT`
2. не обновлять `NEW` после первой вставки - так как будет разное поведение при `INSERT` и `UPSERT`.
   например, поле `title` одноимённое в обеих таблицах (`untrans` и `trans`),
   во время операции `INSERT` колонка `title` была изменена, то в итоге пользователю вернется не тот результат, который он ожидал;
   но при этом ещё раз отправив такой результат пользователь получит ожидаемый ответ.
3. не изменять в триггерах значения в одноимённых колонках, либо изменять на одинаковые значения.
   это касается UI. например, пользователь решил сохранить данные и сохранение в первую таблицу (`untrans`) изменило эти данные,
   например, колонку `title`, тогда в строках представления (`i18n`) относящихся к первой таблице (`untrans`)
   и не имеющих соответствующих записей с языками во второй таблице (`trans`) будет иметь неизвестно откуда взявшееся значение.
   пользователь будет в замешательстве
4. если действие `UPDATE`, но при этом нет записи во второй таблице (`trans`), то нужно делать `INSERT` во вторую таблицу
5. если действие `UPDATE` и таблицы (`untrans` и `trans`) имеют одноимённые колонки, то обновлять (`UPSERT`)
   одноименную колонку только в `trans` - не обновлять `NEW`
6. если действие `INSERT` и таблицы (`untrans` и `trans`) имеют одноимённые колонки,
   то если это значение уже есть в первой таблице (`untrans`),
   то обновить только разноимённые колонки в первой таблице (`untrans`) - не обновлять `NEW`
   если записи в первой таблице нет, то вставить её туда и потом вставить во вторую таблицу (`trans`) - не обновлять `NEW`
7. если есть запись в первой таблице (`untrans`), то в представлении (`i18n`) будут записи по всем существующим языкам таблицы (`langs`),
   так как идёт перекрёстное объединение. расширение придёрживается концепции, что представление имеет такие же законы, как таблица
   поэтому вставку можно делать только не существующих в первой таблице (`trans`) записей.
   поэтому обновление доступно для всех записей представления (`i18n`) включая записи отсутствующие во второй таблице (`untrans`)

# TODO

- [ ] обозначить важные моменты при вставке и обновлении представления
- [x] определить как обновлять данные одинаковых колонок если запись в таблице 1 и 2 уже есть
- [x] продумать что будет если вставить в представление запись, которая есть в первой таблице.
  что будет если вставить запись, которая есть во второй таблице. с условием, что идёт перекрёстное соединение с `langs`
- [ ] попробовать запустить старую версию и посмотреть какие там моменты я делал.
- [x] удалить `ON CONFLICT pk` для вставки в `untran` таблицу - 7 заметка
- [ ] сделать два триггера для удобства просмотра и редактирования, при желании изменить триггер
- [x] проверить как видно код `rule` `trigger` в IDE - оба выглядят круто
- [ ] сделать вывод запросов в консоль перед исполнением
- [ ] сделать два варианта: через правила и через триггеры
- [ ] прописать +/- использовать правила и триггеры
- [ ] при изменении колонок в таблице, связанной с i18n представлениями, нужно пересоздавать представления
- [ ] обновить `EVENT_TRIGGER`
- [ ] попробовать вместо `jsonb_populate_record` использовать `record || record`

# Проверки

- [ ] если я хочу обновить значение, которое есть в 1 и 2 таблице, что будет
- [ ] протестировать на больших данные и нагрузке запросами

