# Заметки

1. `DEFAULT` используется внутри запроса только для полей primary keys - для сохранения вычислений последовательностей.
   В иных случаях использовать `DEFAULT` нет возможности, так как нельзя выяснить внутри триггерной функции или внутри правила
   какая колонка имела значение `DEFAULT` в изначальном запросе.
   Использование `IS DISTINCT FROM` ни к чему не привело.
   Через `GET DIAGNOSTICS stack = PG_CONTEXT;` и переменные `TG_*` нет возможности получить изначальный запрос,
   чтобы так же можно было использовать `DEFAULT`
2. не обновлять `NEW` после первой вставки - так как будет разное поведение при `INSERT` и `UPSERT`.
   например, поле `title` одноимённое в обеих таблицах (`untrans` и `trans`),
   во время операции `INSERT` колонка `title` была изменена, то в итоге пользователю вернется не тот результат, который он ожидал;
   но при этом ещё раз отправив такой результат пользователь получит ожидаемый ответ.
3. не изменять в триггерах значения в одноимённых колонках, либо изменять на одинаковые значения.
   это касается UI. например, пользователь решил сохранить данные и сохранение в первую таблицу (`untrans`) изменило эти данные,
   например, колонку `title`, тогда в строках представления (`i18n`) относящихся к первой таблице (`untrans`)
   и не имеющих соответствующих записей с языками во второй таблице (`trans`) будет иметь неизвестно откуда взявшееся значение.
   пользователь будет в замешательстве
4. если действие `UPDATE`, но при этом нет записи во второй таблице (`trans`), то нужно делать `INSERT` во вторую таблицу
5. если действие `UPDATE` и таблицы (`untrans` и `trans`) имеют одноимённые колонки, то обновлять (`UPSERT`)
   одноименную колонку только в `trans` - не обновлять `NEW`
6. если действие `INSERT` и таблицы (`untrans` и `trans`) имеют одноимённые колонки,
   то если это значение уже есть в первой таблице (`untrans`),
   то обновить только разноимённые колонки в первой таблице (`untrans`) - не обновлять `NEW`
   если записи в первой таблице нет, то вставить её туда и потом вставить во вторую таблицу (`trans`) - не обновлять `NEW`
7. если есть запись в первой таблице (`untrans`), то в представлении (`i18n`) будут записи по всем существующим языкам таблицы (`langs`),
   так как идёт перекрёстное объединение. расширение придёрживается концепции, что представление имеет такие же законы, как таблица
   поэтому вставку можно делать только не существующих в первой таблице (`trans`) записей.
   поэтому обновление доступно для всех записей представления (`i18n`) включая записи отсутствующие во второй таблице (`untrans`)
8. возвращаемый результат в отдельную переменную, чтобы в случае изменения функции в любом месте функции
   была возможность обратиться к изначальному `NEW`, результату первого запроса (`base_new`) и результату второго запроса (`tran_new`).
9. возвращаемый результат рассчитывать в функции, а не использовать
   `SELECT * INTO NEW FROM v_words WHERE (id, lang) = (NEW.id, NEW.lang)`
   так как это затратный оператор, нежели использовать готовые данные.
   использовать `base_new || tran_new`.
10. обновлять primary keys после вставки данных в первую таблицу, чтобы вторая правильно ссылалась

# TODO

- [x] обозначить важные моменты при вставке и обновлении представления
- [x] определить как обновлять данные одинаковых колонок если запись в таблице 1 и 2 уже есть
- [x] продумать что будет если вставить в представление запись, которая есть в первой таблице.
  что будет если вставить запись, которая есть во второй таблице. с условием, что идёт перекрёстное соединение с `langs`
- [x] попробовать запустить старую версию и посмотреть какие там моменты я делал - иначе сделано - не смотрел
- [x] удалить `ON CONFLICT pk` для вставки в `untran` таблицу - 7 заметка
- [x] сделать два триггера для удобства просмотра и редактирования, при желании изменить триггер
- [x] проверить как видно код `rule` `trigger` в IDE - оба выглядят круто
- [x] написать `UPSET` запрос в `trigger` обновления
- [x] найти откуда пробел в запросе `(  id)` - непонятно откуда берутся
- [x] сделать вывод запросов в консоль перед исполнением - вывел в режиме `debug`
- [x] добавить обновление pk после вставки в первую таблицу
- [ ] оптимизировать `jsonb_populate_record`
- [ ] сделать два варианта: через правила и через триггеры
- [ ] прописать +/- использовать правила и триггеры
- [ ] обновить `EVENT_TRIGGER`
- [x] попробовать вместо `jsonb_populate_record` использовать `record || record`
- [x] продумать использовать `SELECT * INTO NEW FROM i18n` или `record || record` - `SELECT` это энергетически затратная операция
- [ ] при изменении колонок в таблице, связанной с i18n представлениями, нужно пересоздавать представления

# Проверки

- [ ] протестировать на больших данные и нагрузке запросами

